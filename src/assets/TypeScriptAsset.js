const Asset = require('../Asset');
const localRequire = require('../utils/localRequire');
const config = require('../utils/config');
const path = require('path');

/**
 * Creates host for parsing tsconfig.json from host for TypeScript compiler
 * Modification of https://github.com/Microsoft/TypeScript/blob/70e26fc7016ada7b2dc6eefb854cc59f92fb4bcd/src/compiler/program.ts#L2855
 * @param {Object} compilerHost
 * @param {string[]} readFileStore Read files while parsing tsconfig.json, should be parent tsconfig.json
 */
const parseConfigHostFromCompilerHost = (compilerHost, readFileStore) => {
  return {
    fileExists: f => compilerHost.fileExists(f),
    readDirectory(root, extensions, excludes, includes, depth) {
      return compilerHost.readDirectory(
        root,
        extensions,
        excludes,
        includes,
        depth
      );
    },
    readFile: f => {
      readFileStore.push(f);
      return compilerHost.readFile(f);
    },
    useCaseSensitiveFileNames: compilerHost.useCaseSensitiveFileNames(),
    getCurrentDirectory: () => compilerHost.getCurrentDirectory(),
    onUnRecoverableConfigFileDiagnostic: () => undefined
  };
};

class TypeScriptAsset extends Asset {
  constructor(name, options) {
    super(name, options);
    this.type = 'js';
  }

  async generate() {
    // require typescript, installed locally in the app
    let typescript = await localRequire('typescript', this.name);
    let transpilerOptions = {
      compilerOptions: {
        module: this.options.scopeHoist
          ? typescript.ModuleKind.ESNext
          : typescript.ModuleKind.CommonJS,
        jsx: typescript.JsxEmit.Preserve,

        // it brings the generated output from TypeScript closer to that generated by Babel
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html
        esModuleInterop: true
      },
      fileName: this.relativeName
    };

    let tsconfig = await this.getConfig(['tsconfig.json']);

    // Overwrite default if config is found
    if (tsconfig) {
      // Files read by TypeScript parser while resolving "extends"
      let readFiles = [];

      // Parse contents of tsconfig.json with TypeScript API to resolve "extends"
      const compilerHost = typescript.createCompilerHost(
        tsconfig.compilerOptions
      );
      const parseConfigHost = parseConfigHostFromCompilerHost(
        compilerHost,
        readFiles
      );
      const tsconfigPath = await config.resolve(this.name, ['tsconfig.json']);
      const parsedTsconfig = typescript.parseJsonConfigFileContent(
        tsconfig,
        parseConfigHost,
        path.dirname(tsconfigPath)
      );

      // Add resolved tsconfig.json to watch list
      for (const file of readFiles) {
        if (file.endsWith('tsconfig.json')) {
          // `path` needs to be normalized for Windows path system compatibility
          // because TypeScript API outputs UNIX style path even if Windows environment
          this.addDependency(path.resolve(file), {includedInParent: true});
        }
      }

      transpilerOptions.compilerOptions = Object.assign(
        transpilerOptions.compilerOptions,
        parsedTsconfig.options
      );
    }
    transpilerOptions.compilerOptions.noEmit = false;
    transpilerOptions.compilerOptions.sourceMap = this.options.sourceMaps;

    // Transpile Module using TypeScript and parse result as ast format through babylon
    let transpiled = typescript.transpileModule(
      this.contents,
      transpilerOptions
    );
    let sourceMap = transpiled.sourceMapText;

    if (sourceMap) {
      sourceMap = JSON.parse(sourceMap);
      sourceMap.sources = [this.relativeName];
      sourceMap.sourcesContent = [this.contents];

      // Remove the source map URL
      let content = transpiled.outputText;
      transpiled.outputText = content.substring(
        0,
        content.lastIndexOf('//# sourceMappingURL')
      );
    }

    return [
      {
        type: 'js',
        value: transpiled.outputText,
        sourceMap
      }
    ];
  }
}

module.exports = TypeScriptAsset;
